---
title: Regular Expression02
date: 2016-07-04 08:41:49
tags: [正则表达式]
toc: false  
---

### 字符类
要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？

很简单，你只需要在方括号里列出它们就行了，像`[aeiou]`就匹配任何一个英文元音字母，`[.?!]`匹配标点符号(.或?或!)。

们也可以轻松地指定一个字符`范围`
像`[0-9]`代表的含意与\d就是完全一致的：一位数字
`[a-z0-9A-Z_]`也完全等同于\w（如果只考虑英文的话）

举个栗子：

`\(?0\d{2}[) -]?\d{8}`
这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等

首先是一个转义字符\\(，它能出现0次或1次(?)，然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。

### 分枝条件
不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。

>正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。

举个栗子：
`0\d{2}-\d{8}|0\d{3}-\d{7}`这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。

`\(?0\d{2}\)?[- ]?\d{8}|0\d{2}[- ]?\d{8}`这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔

`\d{5}-\d{4}|\d{5}`这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。

如果你把它改成`\d{5}|\d{5}-\d{4}`的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。


### 分组
我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。

`(\d{1,3}\.){3}\d{1,3}`是一个简单的IP地址匹配表达式。
请按下列顺序分析它：
`\d{1,3}`匹配1到3位的数字
`(\d{1,3}\.){3}`匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次
最后再加上一个一到三位的数字`(\d{1,3})`

不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。
如果能使用算术比较的话，或许能简单地解决这个问题
但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：
`((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`

### 反义
有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义

```
\W 匹配任意不是字母，数字，下划线，汉字的字符

\S 匹配任意不是空白符的字符

\D 匹配任意非数字的字符

\B 匹配不是单词开头或结束的位置

[^x] 匹配除了x以外的任意字符

[^aeiou] 匹配除了aeiou这几个字母以外的任意字符
```


正则表达式02部分结束















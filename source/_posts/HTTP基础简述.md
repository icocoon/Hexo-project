title: 简述HTTP   
date: 2016-07-02
tags: [HTTP]  
toc: false  
---

首先要了解基本的知识，以及与 HTTP 相关的一些协议。

RFC：俗称互联网设计文档，制定 HTTP 协议的标准文档

>什么是协议：
计算机与网络设备相互想要通信，就必须要有一种规则，规定一系列的事情，比如谁先发起通信啊，用什么语言通信啊，怎么结束啊。万一你和我是不同的操作系统怎么办啊。
所以这个时候，协议就诞生了。


### TCP/IP协议族
我们要上网，就一定要用 TCP/IP 协议族，http 协议是它的子集。

**一般可以认为互联网相关的协议都集合起来就是 TCP/IP 协议族。**

>TCP/IP 协议族重要的一点就是分层，那么为什么要分层呢？
天啦噜，如果不分层，互联网只有一个协议，那万一突然有一个小地方需要改动，怎么办啊，整体换掉吗？
这个时候就体现出分层的好处了，只要把各层之间的接口部分规划好，你要修改哪，就直接替换掉相应的那层就好

具体的各层：

从上到下的四层，分别为
应用层（Application Layer）
传输层（Transport Layer）
网络层（Internet Layer）
连接层（Link Layer）

可以这样理解：
最上面的应用层，顾名思义，是直接与用户打交道的一层，它的协议典型的有 http，FTP，DNS 等。

第二层传输层，提供处于网络连接中的两台计算机之间的数据传输，负责传送文本数据，主要协议是TCP协议，UDP协议；

第三层网络层，负责分配地址和传送二进制数据，主要协议是IP协议；

第四层连接层，负责建立电路连接，是整个网络的物理基础，典型的协议包括以太网、ADSL等等；

<hr>

这个时候理所应当的举个栗子ಥ_ಥ

以 HTTP 举例子：
0：你在客户端发送一个'我要看[B站](http://www.bilibili.com/)'的请求；
1：这个请求理所应当的在应用层，然后从上到下的顺序，到了传输层；
2：传输层开始执行 TCP 协议，一看从应用层发过来的 http 请求，为了方便，它就把这个请求分割啊分割，打上标记号和端口号转发给了网络层；
3：网络层使用了 IP 协议，在 HTTP 协议上面增加了通信目的 Mac 地址，然后甩给了连接层；
4：连接层就默默的发送给了同在连接层 B 站的服务器

接下来就是服务器从连接层一路向上，到了应用层，才算真正的接受到了这个 HTTP 请求，然后它会问一下 B站 的数据库，有没有你要的这个页面的数据，有的话就开始按照刚刚的做法，又倒过来发给你。

IP 协议：负责传输
TCP 协议：负责安全，确保数据能够到达目标
DNS 服务：提供域名和 IP 地址相互之间的解析服务

<hr>

### URL

URL：统一资源定位符，俗称网址

**【协议+认证信息+@+网址+：+端口号】+带层次的文件路径+？+查询字符串+#+片段标志符**

上面这个东西就是 URL

其中：
**网址+:+端口号**可以当做服务器
**带层次的文件路径**不一定是真的文件路径，还有可能是逻辑路径
**片段标志符**又名锚点，起到文档内定位的作用，注意**锚点本身是不包含在请求里的**
**【】**之间被包起来的是源，即origin
通过 location.origin可以拿到源，但是这个 IE8 以下是不支持的


### HTTP 请求
通过上面吧啦吧啦的一大堆，就可以知道**HTTP 请求是用于客户端和服务端之间的通信**

HTTP 请求既然通信，那么一定会发送信息吧，所以信息又分为以下四部分：
1. 请求行
2. 请求头
3. 空行（就是一个回车）
4. 消息体

**GET 请求，消息体一般是空的，但是没有规定不能是有内容**

<hr>
举栗子：
![栗子1](http://upload-images.jianshu.io/upload_images/1806506-f9be6356d7022117.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
请求行就是第一行，三部分组成，第一部分是请求方法，第二部分是请求路径，第三部分是HTTP版本。
然后下面的第二行开始一直到回车之间，就是请求头，由 key：value 组成。
由于这里是 get 请求的，所以没有消息体

比如这个由 post 提交的请求
![栗子2](http://upload-images.jianshu.io/upload_images/1806506-94c8085e803c5632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
它就有了最下面的消息体，并且在请求头中还多了一行：content-type，图片写了 content-type 是 json，消息体也就是 json，所以**消息体和 content-type 一般是同时出现的**

**注意浏览器展示格式不是通过后缀，而是通过请求头里面写的 content-type 决定的**

chrome 做了一些优化，可能与图片中看到的顺序不一样，但是不影响，只要点开 view source 就好。
<hr>

### HTTP 请求的方法：
实际上 HTTP 请求方法有很多，比如： PUT方法，DELETE方法，HEAD方法，CONNECT方法，TRACE方法，
但是最重要的还是 GET 和 POST 方法。

那么 GET 和 POST 的区别有什么呢？

>首先，顾名思义，**GET 用于获取资源（读资源），POST 用于更新资源（写资源）**
其次，**上面已经清清楚楚的举栗子了，get 没有消息体，而 post 有消息体**，但是实际上 get 是可以有 body，但是没人用吧
第三，**post 比 get 安全一些**，但是实际上都差不多啦，只是 post 伪造起来麻烦一点点而已，真的只是一点点。

那么两种方法都用在哪呢？
>get
1. 输入一个 URL
2. 引用的图片，CSS，js 之类的
3. 用 jquery 的 $.get()

>post
1. form 表单提交
2. jquery 的 $.post()


### cookie

首先 http 是无状态的协议，它不对之前的请求和响应做出管理。
那么问题来了，那么岂不是我每次新打开一个页面，我就要登陆一次？WTF？黑人问号.jpg
为了解决这个问题，引入了 cookie 技术，通过在请求和响应中写入 cookie 信息来控制客户端的状态。
只要客户端保存了 cookie，下一次客户端发送请求的时候，客户端会自动在请求头中加入 cookie 值，服务器由于第一次已经接受了 cookie，当再次收到请求的时候，会对比服务器上的记录，最后得到你就是刚刚的用户这种状态消息。


### HTTP状态码
这个我只记得200是好的，响应成功，404就是错误之类，貌似还有很多，不记得额。